# describes a minimum whole-degreed rectangle enclosing the given VMAP0 item
array set vmap0ItemEditionExtent {
    eurnasia_005 {30 82 -32 180}
    noamr_005 {-31 84 -180 -7}
    sasaus_005 {-56 51 25 180}
    soamafr_005 {-90 30 -180 180}
}    

# describes a minimum whole-degreed rectangle enclosing the given VMAP1 item
# S N W E
array set vmap1ItemExtent {
    001 {65 84 -180 -141.75}
    002 {65 84 -144 -108}
    003 {63 84 -108.75 -60}
    004 {42 90 -180 0}
    005 {57.5 84 0 34}
    006 {60 84 31.5 51}
    007 {60 84 48 72}
    008 {60 84 71.25 94.5}
    009 {60 84 93 117}
    010 {60 84 114 136}
    011 {58 84 134.75 157.5}
    012 {40 84 141 172.5}
    013 {40 84 168.75 180}
    014a {0 40 143 180}
    014b {-60 0 142.5 180}
    014c {0 65 -180 -141}
    014d {-40 0 -180 -120}
    015 {42 65 -156.25 -137.5}
    016 {60 65 -138 -126}
    017 {60 65 -126 -118}
    018 {60 65 -118 -108}
    019 {60 68 -108 -96.75}
    020 {60 68 -98 -90}
    021 {54 68 -90 -72}
    022 {72 61.5 -72 -60}
    023 {54 61.5 -72 -50}
    024a {42 65 -24 3}
    024b {49 60 -7.5 3}
    025 {55 60 3 19.5}
    026 {54 60 19.5 31.5}
    027 {54 60 31.5 43.5}
    028 {54 60 43.5 55.5}
    029 {54 60 55.5 67.5}
    030 {54 60 67.5 79.5}
    031 {54 60 79.5 91.5}
    032 {54 60 91.5 103.5}
    033 {54 60 103.5 115.5}
    034 {54 60 115.5 127.5}
    035 {54 60 127.5 141}
    036 {54 60 -138 -126}
    037 {54 60 -126 -118.5}
    038 {54 60 -118.5 -108}
    039 {54 60 -108 -97.5}
    040 {54 60 -97.5 -90}
    041 {49 54 -138 -118.5}
    042 {49 54 -122.5 -107.5}
    043 {49 54 -108 -97.5}
    044 {48 54 -97.5 -90}
    045 {48 54 -90 -82.5}
    046 {48 54 -82.5 -71.25}
    047 {42 54 -72 -60}
    048 {42 54 -60 -47.5}
    049 {47 55 1.5 15}
    050 {48 55 12 25.5}
    051 {48 54 25 37.5}
    052 {48 54 37.5 49.5}
    053 {48 54 48.75 60}
    054 {45 54 60 72}
    055 {45 54 71.25 82.5}
    056 {45 54 82.5 96}
    057 {45 54 95 109.5}
    058 {45 54 108.75 120}
    059 {45 54 120 133.5}
    060 {45 55 132.5 145.5}
    061 {42 49 -137.5 -117.5}
    062 {42 49 -117.5 -107.5}
    063 {42 49 -107.5 -97.5}
    064 {42 48 -97.5 -90}
    065 {42 48 -90 -81.25}
    066 {42 48 -81.25 -71.25}
    067 {41 51 -6.25 10}
    068 {42 48 12.5 25}
    069 {40 48 25 47.5}
    070 {40 48 47.5 66.25}
    071 {40 45 66.25 81.25}
    072 {40 45 81.25 93.75}
    073 {40 45 93.75 106.25}
    074 {40 45 106.25 118.75}
    075 {38 45 118.75 130}
    076 {41 50 130 156.25}
    077 {30 42 -141.25 -120}
    078 {36 42 -120 -110}
    079 {36 42 -110 -100}
    080 {36 42 -100 -90}
    081 {36 42 -90 -80}
    082 {36 42 -80 -35}
    083 {30 44 -35 6.25}
    084 {35 47 6.25 19}
    085 {34 42 19 30}
    086 {35 40 31 45}
    087 {35 40 45 60}
    088 {36 40 60 69}
    089 {36 40 69 78}
    090 {36 40 78 87}
    091 {36 40 87 96}
    092 {36 40 96 105}
    093 {36 40 105 114}
    094 {36 40 114 124}
    095 {33 42 124 133}
    096 {20 42 124 156.25}
    097 {30 36 -120 -108}
    098 {26 36 -108 -102}
    099 {26 36 -102 -94}
    100 {26 36 -94 -85}
    101 {23 36 -85 -35}
    102 {30 36 -12 0}
    103 {30 38 0 6}
    104 {30 38 6 12}
    105 {30 35 12 25}
    106 {30 36 25 42}
    107 {30 35 42 51}
    108 {30 35 51 60}
    109 {30 36 60 69}
    110 {30 36 69 78}
    111 {30 36 78 87}
    112 {30 36 87 96}
    113 {30 36 96 105}
    114 {30 36 105 114}
    115 {30 36 114 124}
    116 {0 30 -141 -102}
    117 {0 26 -102 085}
    118 {15 23 -85 -50}
    119 {21 30 -50 -12}
    120 {21 30 -6 -12}
    121 {21 30 -6 0}
    122 {21 30 0 6}
    123 {21 30 6 12}
    124 {21 30 12 18}
    125 {21 30 18 25}
    126 {21 30 25 30}
    127 {21 30 30 36}
    128 {21 30 36 43}
    129 {21 30 43 49}
    130 {21 30 49 60}
    131 {24 30 60 70}
    132 {24 30 70 79}
    133 {24 30 79 88}
    134 {24 30 88 97}
    135 {24 30 97 106}
    136 {24 30 106 115}
    137 {22 30 115 126}
    138 {12 21 -50 -12}
    139 {12 21 -12 -6}
    140 {12 21 -6 0}
    141 {12 21 0 6}
    142 {12 21 6 12}
    143 {21 12 12 18}
    144 {12 21 18 25}
    145 {10 21 25 30}
    146 {10 21 30 36}
    147 {10 21 36 43}
    148 {10 21 43 49}
    149 {10 21 49 60}
    150 {18 24 60 78}
    151 {18 24 78 88}
    152 {18 24 88 98}
    153 {18 24 98 108}
    154 {18 24 108 118}
    155 {0 15 -85 -72}
    156 {0 15 -72 -66}
    157 {0 15 -66 -60}
    158 {0 15 -60 -32}
    159 {3 12 -32 -6}
    160 {3 12 -6 0}
    161 {3 12 0 6}
    162 {3 12 6 12}
    163 {3 12 12 18}
    164 {3 12 18 25}
    165 {3 10 25 30}
    166 {3 10 30 36}
    167 {5 10 36 42}
    168 {3 10 42 70}
    169 {-11 18 60 78}
    170 {-11 18 78 94}
    171 {7 18 94 102}
    172 {7 18 102 110}
    173 {3 22 110 143}
    174a {-84 -40 -180 -120}
    174b {-84 -40 67.5 180}
    175 {-9 0 -120 -72}
    176 {-9 0 -72 -64}
    177 {-9 0 -64 -56}
    178 {-9 0 -56 -48}
    179 {-9 0 -48 -40}
    180 {-18 0 -40 -32}
    181 {-6 3 -32 15}
    182 {-6 3 15 21}
    183 {-6 3 21 27}
    184 {-6 3 27 33}
    185 {-7 5 33 42}
    186 {-7 3 42 70}
    187 {-6 7 94 108}
    188 {-6 7 108 119}
    189 {-11 3 94 131}
    190 {-12 3 131 156}
    191 {-18 -9 -120 -69}
    192 {-18 -9 -69 -64}
    193 {-18 -9 -65 -56}
    194 {-18 -9 -56 -48}
    195 {-18 -9 -48 -40}
    196 {-18 -6 -32 18}
    197 {-15 -6 18 24}
    198 {-15 -6 24 30}
    199 {-15 -6 30 36}
    200 {-24 -6 36 70}
    201 {-18 -11 70 134}
    202 {-18 -9.25 134 156}
    203 {-27 -18 -120 -66}
    204 {-27 -18 -66 -60}
    205 {-27 -18 -60 -54}
    206 {-27 -18 -54 -48}
    207 {-27 -18 -48 -13}
    208 {-24 -15 -13 18}
    209 {-24 -15 18 24}
    210 {-24 -15 24 30}
    211 {-24 -15 30 36}
    212 {-40 -12 42 70}
    213 {-27 -18 70 120}
    214 {-27 -18 120 126}
    215 {-27 -18 126 132}
    216 {-27 -18 132 138}
    217 {-27 -18 138 144}
    218 {-27 -18 144 156}
    219 {-36 -27 -120 -65}
    220 {-36 -27 -65 -60}
    221 {-36 -27 -60 -54}
    222 {-36 -27 -54 -13}
    223 {-30 -24 -13 24}
    224 {-30 -24 24 42}
    225 {-40 -27 70 121}
    226 {-40 -27 121 130}
    227 {-40 -27 130 139}
    228 {-36 -27 139 147}
    229 {-36 -27 147 156}
    230 {-45 -36 -120 -65}
    231 {-45 -36 -65 -14}
    232 {-84 -30 -15 68.75}
    233 {-40 -36 139 157.5}
    234 {-84 -45 -121.5 -13.5}
}

foreach item [lsort [array names vmap1ItemExtent]] {
    set extent $vmap1ItemExtent($item)
    # find latest edition
    # insert into vmap1ItemEditionExtent
    set editionPaths [glob -nocomplain -directory ${vmap1Root} ${item}*]

    set itemEditions {}
    foreach editionPath $editionPaths {
	set split [split $editionPath /]
	set itemEdition [lindex $split [expr [llength $split] - 1]]
	lappend itemEditions $itemEdition
    }

    set itemEditions [lsort $itemEditions]

    # puts -nonewline "$item $itemEditions "

    if {[llength $itemEditions] == 1} {
	# puts "do $itemEditions"
	set vmap1ItemEditionExtent($itemEditions) $extent
    } else {
	if {$item == "086"} {
	    if {$itemEditions == "086_fill 086_pre"} {
		# puts "do fill and pre"
		set vmap1ItemEditionExtent(086_fill) $extent
		set vmap1ItemEditionExtent(086_pre) $extent
	    } else {
		set itemEditions [lsort -decreasing $itemEditions]
		foreach itemEdition $itemEditions {
		    if {[string first "fill" $itemEdition] < 0 && [string first "pre" $itemEdition] < 0} {
			# puts "do $itemEdition"
			set vmap1ItemEditionExtent($itemEdition) $extent
			break
		    }
		}
	    }
	} else {
	    set last [lindex $itemEditions [expr [llength $itemEditions] - 1]]
	    if {[string first "fill" $last] < 0} {
		# puts "do $last"
		set vmap1ItemEditionExtent($last) $extent
	    } else {
		set nextToLast [lindex $itemEditions [expr [llength $itemEditions] - 2]]
		# puts "do $nextToLast"
		set vmap1ItemEditionExtent($nextToLast) $extent
	    }
	}
    }
}

# map from cbs class id to filter prefix, vmap1 feature classes (which are filter suffixes), and dbf fields to keep
# these could be queried from the dbf files, but we'll assume they're fixed for now

# roadl
# 1 f_code facc feature code
# 7 nam name
# 8 rst road/runway surface type
# 9 rtt route intended use
array set roadlDbfFieldIndices  {f_code 1 nam 7 rst 8 rtt 9}

# trackl
# 1 f_code facc feature code
array set tracklDbfFieldIndices {f_code 1}

# traill
# 1 f_code facc feature code
array set traillDbfFieldIndices {f_code 1}

# bridge
# 1 f_code facc feature code
# 8 tuc transportation use category
array set bridgelDbfFieldIndices {f_code 1 tuc 8}

# tunnell
# 1 f_code facc feature code
# 3 nam name
# 4 tuc transportation use category
array set tunnellDbfFieldIndices {f_code 1 nam 3 tuc 4}

# watrcrsl
# 1 f_code facc feature code
# 3 hyc hydrological category
# 4 nam name
array set watrcrslDbfFieldIndices {f_code 1 nam 4 hyc 3}

# aquedctl
# 1 f_code facc feature code
array set aquedctlDbfFieldIndices {f_code 1}

# cropa
# 1 f_code facc feature code
array set cropaDbfFieldIndices {f_code 1}

# orcharda
# 1 f_code facc feature code
array set orchardaDbfFieldIndices {f_code 1}

# treesa
# 1 f_code facc feature code
array set treesaDbfFieldIndices {f_code 1}

# builtupa
# 1 f_code facc feature code
# 3 nam name
# 4 use usage
array set builtupaDbfFieldIndices {f_code 1 nam 3 use 4}

# lakeresa
# 1 f_code facc feature code
# 3 hyc hydrological category
# 4 nam name
array set lakeresaDbfFieldIndices {f_code 1 nam 4 hyc 3}

# coasta
# 1 f_code facc feature code
array set coastaDbfFieldIndices {f_code 1}

# watrcrsa
# 1 f_code facc feature code
# 2 hyc hydrological category
# 3 nam name
array set watrcrsaDbfFieldIndices {f_code 1 nam 3 hyc 2}

# grounda
# 1 f_code facc feature code
# 2 mcc material composition category
array set groundaDbfFieldIndices {f_code 0 MATERIAL_C 2}

# 086_pre kludge; used test with news=(38 35 31 34), dipped south to pick up some 106
array set hydro_arcDbfFieldIndices {FACC_FEATU 7 NAME 14}
array set hydro_polyDbfFieldIndices {FACC_FEATU 4 NAME 9}
array set pop_polyDbfFieldIndices {FACC_FEATU 4 NAME 9}
array set trans_arcDbfFieldIndices {FACC_FEATU 7 NAME 20}
array set veg_polyDbfFieldIndices {FACC_FEATU 1 NAME 0}

# vmap0_fill kludge
array set vm0_aquecanlDbfFieldIndices {FACC_FEATU 1 NAME 4}
array set vm0_builtupaDbfFieldIndices {FACC_FEATU 1 NAME 2}
array set vm0_cropaDbfFieldIndices {FACC_FEATU 1}
array set vm0_grassaDbfFieldIndices {FACC_FEATU 1}
array set vm0_groundaDbfFieldIndices {FACC_FEATU 1 SURFACE_MA 2}
array set vm0_inwateraDbfFieldIndices {FACC_FEATU 1 NAME 3 HYDROLOGIC 2}
array set vm0_oceanseaDbfFieldIndices {FACC_FEATU 1 NAME 2}
array set vm0_roadlDbfFieldIndices {FACC_FEATU 1 ROUTE_INTE 5}
array set vm0_swampaDbfFieldIndices {FACC_FEATU 1}
array set vm0_traillDbfFieldIndices {FACC_FEATU 1}
array set vm0_treesaDbfFieldIndices {FACC_FEATU 1}
array set vm0_watrcrslDbfFieldIndices {FACC_FEATU 1 NAME 3 HYDROLOGIC 2}

# filterPrefix cbsClassVectorType vmap1Classes dbfFieldsToKeep
array set _cbsTerrainClasses {
    201 {Rivers1_Small_River "ARC" {watrcrsl} {FACC_FEATU f_code NAME nam HYDROLOGIC}}
}
array set cbsTerrainClasses {
    101 {Roads1_Loose_Surface "ARC" {roadl trackl traill trans_arc vm0_roadl vm0_traill} {FACC_FEATU f_code NAME nam ROAD_RUNWA rst}}
    102 {Roads2_Hard_Surface "ARC" {roadl bridgel tunnell trans_arc vm0_roadl} {FACC_FEATU f_code NAME nam ROAD_RUNWA rst ROUTE_INTE rtt TRANSPORTA tuc}}
    103 {Roads3_Dual_Highways "ARC" {roadl vm0_roadl} {FACC_FEATU f_code ROAD_RUNWA rst ROUTE_INTE rtt}}
    201 {Rivers1_Small_River "ARC" {watrcrsl aquedctl hydro_arc vm0_aquecanl} {FACC_FEATU f_code NAME nam HYDROLOGIC hyc}}
    202 {Rivers2_Medium_River "ARC" {watrcrsl vm0_watrcrsl} {FACC_FEATU f_code NAME nam HYDROLOGIC hyc}}
    203a {Rivers3_Large_River "POLYGON" {watrcrsa} {f_code nam hyc}}
    203l {Rivers3_Large_River "ARC" {vm0_watrcrsl} {FACC_FEATU f_code NAME nam HYDROLOGIC hyc}}
    302 {Vegetation_Sparse "POLYGON" {cropa veg_poly orcharda vm0_cropa vm0_grassa} {FACC_FEATU f_code}}
    303 {Vegetation_Moderate "POLYGON" {orcharda veg_poly treesa vm0_treesa} {FACC_FEATU f_code}}
    401 {Urbanization_Village "POLYGON" {builtupa} {f_code nam use}}
    402 {Urbanization_Town "POLYGON" {builtupa} {f_code nam use}}
    403 {Urbanization_City "POLYGON" {builtupa pop_poly vm0_builtupa} {FACC_FEATU f_code NAME nam USAGE use}}
    501 {Trafficability_Water "POLYGON" {lakeresa coasta hydro_poly vm0_inwatera vm0_oceansea} {FACC_FEATU f_code NAME nam HYDROLOGIC hyc}}
    505 {Trafficability_Mountainous "POLYGON" {grounda vm0_grounda} {FACC_FEATU f_code SURFACE_MA mcc}}
    506 {Trafficability_Marsh "POLYGON" {swampa veg_poly vm0_swampa} {FACC_FEATU f_code NAME nam}}
}

# lifted from cibmos.tcl
proc rectsOverlap {n1 e1 w1 s1 n2 e2 w2 s2} {
    if {$s1 > $n2 || $n1 < $s2 || $e1 < $w2 || $w1 > $e2} {
	return 0
    } else {
	return 1
    }
}

# product should be either vmap0 or vmap1
# feature class should be something like cropa, roadl, swampa, etc.
# s,n,w,e should be in degrees
# this routine returns all shape files that might contain requested data
proc vmapItemToShapeFiles {product featureClass s n w e} {
    global ${product}Root
    global ${product}ItemEditionExtent

    puts "vmapItemToShapeFiles $product $featureClass $s $n $w $e"

    set files {}
    foreach item [array names ${product}ItemEditionExtent] {
	set extent [set ${product}ItemEditionExtent($item)]
	set ss [lindex $extent 0]
	set nn [lindex $extent 1]
	set ww [lindex $extent 2]
	set ee [lindex $extent 3]

	puts "checking $product item $item"

	if {[rectsOverlap $n $e $w $s $nn $ee $ww $ss] == 1} {
	    set itemDir [set ${product}Root]/${item}
	    puts "globbing ${itemDir}/${featureClass}*.shp"
	    set files [concat $files [glob -nocomplain ${itemDir}/${featureClass}*.shp]]
	}
    }

    return $files
}

# generate 101, 102, etc. CBS class shape files for each of the VMAP feature class sources
# store in the tdpsDatabaseDir
proc extractCbsClassShapeFiles {s n w e} {
    global tdpsDatabase
    if {$tdpsDatabase == ""} {
	tk_messageBox -message "Select or create a TDPS database first"
	return
    }

    global tdpsDatabaseDir
    if {! [file isdirectory $tdpsDatabaseDir] || ! [file writable $tdpsDatabaseDir]} {
	tk_messageBox -message "Error writing to TDPS database directory \"${tdpsDatabaseDir}\"";
	return
    }

    array set usedItemExtents {}

    global cbsTerrainClasses
    # foreach of the cbs class ids like 101 102 103 201 202 203a 203l etc.
    foreach cbsClass [array names cbsTerrainClasses] {
	# 202 {Rivers2_Medium_River "ARC" {watrcrsl vm0_watrcrsl} {FACC_FEATU NAME HYDROLOGIC}}
	# 203a {Rivers3_Large_River "POLYGON" {watrcrsa} {FACC_FEATU NAME HYDROLOGIC}}

	# get the filter prefix and suffixes for the cbs class
	set list $cbsTerrainClasses($cbsClass)
	set filterPrefix [lindex $list 0]
	set cbsClassVectorType [lindex $list 1]
	set vmap1Classes [lindex $list 2]
	set dbfFieldsToKeep [lindex $list 3]

	# create the cbs class shape file
	global tdpsDatabaseDir
	addStatus "Creating ${tdpsDatabaseDir}/CBS_${filterPrefix}_${cbsClass}"

	set shpFileOut [SHPCreate ${tdpsDatabaseDir}/CBS_${filterPrefix}_${cbsClass} $cbsClassVectorType]
	set dbfFileOut [DBFCreate ${tdpsDatabaseDir}/CBS_${filterPrefix}_${cbsClass}]

	set newVector 0

	# every field will be FTString 80 0
	foreach field $dbfFieldsToKeep {
	    DBFAddField $dbfFileOut $field "FTString" 80 0
	}

	# foreach of the filter suffixes like roadl watrcrsl bridgel vm_watrcrsl veg_poly etc.
	foreach filterSuffix $vmap1Classes {
	    # the "poly" is for the 086_pre kludge
	    if {([string index $filterSuffix [expr [string length $filterSuffix] - 1]] == "a") || [string first "poly" $filterSuffix] >= 0} {
		set vectorType "POLYGON"
	    } else {
		set vectorType "ARC"
	    }

	    if {$vectorType != $cbsClassVectorType} {
		tk_messageBox -message "Ignoring VMAP class $filterSuffix, since it is $vectorType, but CBS class $cbsClass is $cbsClassVectorType"
		continue
	    }

	    # calculate the filter name
	    set filterName ${filterPrefix}_${filterSuffix}
	    global dataVolume
	    if {$dataVolume == "Low"} {
		global filters
		set names [array names filters]
		if {[lsearch $names ${filterName}_lowVolume] >= 0} {
		    set filterName ${filterName}_lowVolume
		}
	    }

	    # calculate the list of input shape files that contribute to this cbs class
	    set sourceFiles [vmapItemToShapeFiles vmap1 $filterSuffix $s $n $w $e]

	    if {[llength $sourceFiles] == 0} {
		addStatus "No source files for vmap1 $filterSuffix in aoi"
	    }

	    # filter each of the contributing files into the output cbs class shape file
	    # The reason that there may be multiple source files for a
	    # given filter suffix (i.e. vmap feature class) is because the original vmap file may have been
	    # divided into several shape files, because muse couldn't extract the whole data set at once.
	    foreach file $sourceFiles {
		addStatus "Filtering $file with $filterName ... " true
		flush stdout
		set vectorCountForFile 0

		set shpFileIn [SHPOpen $file]
		global argv
		if {[lsearch $argv "expert"] >= 0} {
		    puts "Filtering $file opened with handle $shpFileIn"
		}
		set dbfFileIn [DBFOpen $file]

		set vectorCount [DBFGetRecordCount $dbfFileIn]

		for {set vector 0} {$vector < $vectorCount} {incr vector} {
		    if {[catch {set vectorProperties [getVectorPropertiesFromOpenFile $dbfFileIn $vector]} postMortem]} {
			error "caught an error: $postMortem\nwith dbfFileIn==$dbfFileIn vector==$vector"
		    }

		    if {[applyFilter $filterName $vectorProperties] && [shapeTouchesBox $shpFileIn $vector $s $n $w $e]} {
			incr vectorCountForFile

			SHPCopyVector $shpFileIn $vector $shpFileOut

			set toFieldIndex 0
			foreach dbfField $dbfFieldsToKeep {
			    global ${filterSuffix}DbfFieldIndices

			    if {[lsearch [array names ${filterSuffix}DbfFieldIndices] $dbfField] >= 0} {
				set fromFieldIndex [set ${filterSuffix}DbfFieldIndices($dbfField)]
				DBFCopyString $dbfFileIn $vector $fromFieldIndex $dbfFileOut $newVector $toFieldIndex
			    }
			    incr toFieldIndex
			}

			incr newVector
		    }
		}

		addStatus "$vectorCountForFile vectors pass"

		DBFClose $dbfFileIn
		SHPClose $shpFileIn

		global vmap1ItemEditionExtent
		if {$vectorCountForFile > 0} {
		    set split [split $file /]
		    set itemEdition [lindex $split [expr [llength $split] - 2]]
		    set dir [lrange $split 0 [expr [llength $split] - 2]]
		    set join [join $dir /]
		    set usedItemExtents($join) $vmap1ItemEditionExtent($itemEdition)
		}
	    }
	}

	DBFClose $dbfFileOut
	SHPClose $shpFileOut
    }

    addStatus "Used items with bounding boxes in signed degrees (S N W E):"
    foreach item [lsort [array names usedItemExtents]] {
	addStatus "$item: $usedItemExtents($item)"
    }
}

proc updateSourceData {type} {
    # typs is CADRG, VMAP1, DEM, MOSAIC_DEM, or EXPORT_CADRG

    # vector extractor needs path to dht file, lib, coverage, feature and output shape name
    # user provides dht path, typically on cd
    # lib is found in same directory as dht file
    # all coverage/feature combinations used by tdps are extracted to output directory, provided by user
    # output sent to status window and vmap extraction log

    set w .updateVmap1
    catch {destroy $w}
    toplevel $w
    wm protocol $w WM_DELETE_WINDOW "destroy $w"
    if {$type == "MOSAIC_DEM"} {
	set title "Mosaic DEM"
    } elseif {$type == "EXPORT_CADRG"} {
	set title "Export CADRG"
    } else {
	set title "Update $type Source Data"
    }
    wm title $w $title
    wm iconname $w $title

    set f $w.frame
    frame $f
    pack $f -fill both -expand true

    set row 0

    grid $f -row $row -column 0 -sticky news
    grid configure $f -columnspan 3
    grid columnconfigure $f 0 -weight 0
    grid columnconfigure $f 1 -weight 1
    grid columnconfigure $f 2 -weight 0

    set l $f.label
    switch $type {
	VMAP1 {
	    set label "VMAP1 dht file:"
	    set command "updateVmap1SourceData"
	}
	DEM {
	    set label "DEM data file:"
	    set command "updateDemSourceData"
	}
	CADRG {
	    set label "CADRG a.toc file:"
	    set command "updateCadrgSourceData"
	}
	MOSAIC_DEM {
	    set label "Output Mosaic File"
	    set command "mosaicDemData"
	}
	EXPORT_CADRG {
	    set label "Input Red Channel File"
	    set command "exportCadrg"
	}
	default {
	    set label ""
	    set command ""
	}
    }

    label $l -text $label
    grid $l -row $row -column 0 -sticky e

    set e $f.entry
    entry $e -textvariable update${type}SourcePath -width 40
    grid $e -row $row -column 1 -sticky news

    set mb $f.browse
    if {$type == "MOSAIC_DEM"} {
	button $mb -text "Browse ..." -command "set update${type}SourcePath \[getFileForSave $type\]"
    } else {
	button $mb -text "Browse ..." -command "set update${type}SourcePath \[getFileForOpen $type\]"
    }
    grid $mb -row $row -column 2 -sticky news
    
    if {$type == "EXPORT_CADRG"} {
	incr row

	set label "Output TIFF File"
	set l $f.label2
	label $l -text $label
	grid $l -row $row -column 0 -sticky e

	set e $f.entry2
	entry $e -textvariable update${type}DestPath -width 40
	grid $e -row $row -column 1 -sticky news

	set mb $f.browse2
	button $mb -text "Browse ..." -command "set update${type}DestPath \[getFileForSave $type\]"
	grid $mb -row $row -column 2 -sticky news
    }

    if {$type == "VMAP1"} {
	incr row

	set l $f.label$row
	label $l -text "Item:"
	grid $l -row $row -column 0 -sticky e
	set e $f.entry$row
	entry $e -textvariable vmap1Item -width 8
	grid $e -row $row -column 1 -sticky w
	global vmap1Item
	set vmap1Item ""

	incr row

	set l $f.label$row
	label $l -text "Edition:"
	grid $l -row $row -column 0 -sticky e
	set e $f.entry$row
	entry $e -textvariable vmap1Edition -width 8
	grid $e -row $row -column 1 -sticky w
	global vmap1Edition
	set vmap1Edition ""
    }

    if {$type == "DEM" || $type == "CADRG" || $type == "MOSAIC_DEM"} {
	incr row

	set g $f.grid
	frame $g
	grid $g -row $row -column 0
	grid configure $g -columnspan 3

	set l $g.aoiLabel
	if {$type == "CADRG"} {
	    label $l -text "10x10"
	} else {
	    label $l -text "AOI"
	}
	grid $l -row 1 -column 1 -padx 1 -pady 1
	set e $g.aoiN_${type}
	entry $e -width 8 -textvariable update${type}_aoiN
	global update${type}_aoiN
	set update${type}_aoiN 90
	grid $e -row 0 -column 1 -padx 1 -pady 1
	set e $g.aoiS_${type}
	entry $e -width 8 -textvariable update${type}_aoiS
	global update${type}_aoiS
	set update${type}_aoiS -90
	grid $e -row 2 -column 1 -padx 1 -pady 1
	set e $g.aoiW_${type}
	entry $e -width 9 -textvariable update${type}_aoiW
	global update${type}_aoiW
	set update${type}_aoiW -180
	grid $e -row 1 -column 0 -padx 1 -pady 1
	set e $g.aoiE_${type}
	entry $e -width 9 -textvariable update${type}_aoiE
	global update${type}_aoiE
	set update${type}_aoiE 180
	grid $e -row 1 -column 2 -padx 1 -pady 1
    }

    if {$type == "CADRG"} {
	incr row

	set b $f.skip
	checkbutton $b -text "Use last extraction" -variable useLastExtraction
	grid $b -row $row -column 0 -sticky w
    }

    if {$type != "MOSAIC_DEM" && $type != "EXPORT_CADRG"} {
	incr row

	set bf $f.buttonFrame_${row}
	frame $bf
	grid $bf -row $row -column 0 -sticky news
	grid configure $bf -columnspan 3
	grid columnconfigure $bf 0 -weight 0
	grid columnconfigure $bf 1 -weight 1

	set cb $bf.rb1
	radiobutton $cb -text "Output to alternate directory" -variable ${type}_useAlternateOutdir -value 1
	grid $cb -row 0 -column 0 -sticky w

	global ${type}_useAlternateOutdir
	set ${type}_useAlternateOutdir 1

	set e $bf.entry
	entry $e -textvariable ${type}_outdir
	grid $e -row 0 -column 1 -sticky news

	set cb $bf.rb2
	radiobutton $cb -text "Overwrite existing TDPS database" -variable ${type}_useAlternateOutdir -value 0
	grid $cb -row 1 -column 0 -sticky w
    }

    incr row

    set bf $f.buttonFrame
    frame $bf
    grid $bf -row $row -column 0
    grid configure $bf -columnspan 3

    set b $bf.import
    if {$type == "MOSAIC_DEM"} {
	button $b -text "Mosaic" -command $command
    } elseif {$type == "EXPORT_CADRG"} {
	button $b -text "Export" -command $command
    } else {
	button $b -text "Import" -command $command
    }
    grid $b -row $row -column 0

    set b $bf.cancel
    button $b -text "Close" -command "destroy $w"
    grid $b -row $row -column 1

}

proc exportCadrg {} {
    global updateEXPORT_CADRGSourcePath
    global updateEXPORT_CADRGDestPath

    set split [split $updateEXPORT_CADRGDestPath /]
    set path [lrange $split 0 [expr [llength $split] - 2]]
    if {$path == ""} {
	set DIRout "."
    } else {
	set DIRout [join $path /]
    }
    set out [lindex $split [ expr [llength $split] - 1]]

    # file names are either like adrg.red or like n0e30_adrg_blu.img
    set split [split $updateEXPORT_CADRGSourcePath /]
    set path [lrange $split 0 [expr [llength $split] - 2]]
    set file [lindex $split [expr [llength $split] - 1]]
    if {$path == ""} {
	set path "."
    } else {
	set path [join $path /]
    }
    set redIdx [string first "red" $file]

    set REDin ${path}/[string replace $file $redIdx [expr $redIdx + 2] "red"]
    set GRNin ${path}/[string replace $file $redIdx [expr $redIdx + 2] "grn"]
    set BLUin ${path}/[string replace $file $redIdx [expr $redIdx + 2] "blu"]

    set cmd "export_adrg.pdf REDin=$REDin GRNin=$GRNin BLUin=$BLUin DIRout=${DIRout}/ out=$out"

    global argv
    if {[lsearch $argv "expert"] >= 0} {
	puts $cmd
    }

    if {[catch {exec taetm -s "${cmd}"} erVar]} {
	puts "export_adrg: $erVar"
    }

    tk_messageBox -message "CADRG export complete" -title "CADRG export complete"
}

proc mosaicDemData {} {
    global updateMOSAIC_DEMSourcePath
    global updateMOSAIC_DEM_aoiN
    global updateMOSAIC_DEM_aoiS
    global updateMOSAIC_DEM_aoiE
    global updateMOSAIC_DEM_aoiW
    global srtmRoot
    
    if {[string first "." $updateMOSAIC_DEM_aoiN] >= 0 ||
	[string first "." $updateMOSAIC_DEM_aoiS] >= 0 ||
	[string first "." $updateMOSAIC_DEM_aoiE] >= 0 ||
	[string first "." $updateMOSAIC_DEM_aoiW] >= 0} {
	tk_messageBox -message "AOI limits must use integral values" -title "Error: Fractional AOI Limits"
	return
    }

    if {[string first ".img" $updateMOSAIC_DEMSourcePath] >= 0} {
	set format 1

	set out $updateMOSAIC_DEMSourcePath
    } else {
	set format 0

	if {[string first ".tif" $updateMOSAIC_DEMSourcePath] < 0 &&
	    [string first ".TIF" $updateMOSAIC_DEMSourcePath] < 0} {

	    set out "${updateMOSAIC_DEMSourcePath}.tif"
	} else {
	    set out $updateMOSAIC_DEMSourcePath
	}
    }

    set cmd "mos_dem.pdf DIRin=$srtmRoot out=$out slat=$updateMOSAIC_DEM_aoiS slon=$updateMOSAIC_DEM_aoiW elat=$updateMOSAIC_DEM_aoiN elon=$updateMOSAIC_DEM_aoiE format=$format"
    global argv
    if {[lsearch $argv "expert"] >= 0} {
	puts $cmd
    }

    if {[catch {exec taetm -s "${cmd}"} erVar]} {
	puts "mos_dem: $erVar"
    }

    tk_messageBox -message "DEM mosaic complete" -title "DEM mosaic complete"
}

proc updateCadrgSourceData {} {
    global updateCADRGSourcePath
    global updateCADRG_aoiN
    global updateCADRG_aoiS
    global updateCADRG_aoiE
    global updateCADRG_aoiW
    global startingUpdateCadrgSourceData
    
    set startingUpdateCadrgSourceData 1

    if {[string first "." $updateCADRG_aoiN] >= 0 ||
	[string first "." $updateCADRG_aoiS] >= 0 ||
	[string first "." $updateCADRG_aoiE] >= 0 ||
	[string first "." $updateCADRG_aoiW] >= 0} {
	tk_messageBox -message "10X10 limits must use integral values"
	return
    }

    if {[expr $updateCADRG_aoiN % 10] != 0 ||
	[expr $updateCADRG_aoiS % 10] != 0 ||
	[expr $updateCADRG_aoiE % 10] != 0 ||
	[expr $updateCADRG_aoiW % 10] != 0} {
	tk_messageBox -message "10x10 limits must be multiples of 10"
	return
    }

    if {[expr $updateCADRG_aoiN - $updateCADRG_aoiS] != 10 ||
	[expr $updateCADRG_aoiE - $updateCADRG_aoiW] != 10} {
	tk_messageBox -message "10x10 limits must be 10 degrees wide/high"
	return
    }

    puts "update cadrg with $updateCADRGSourcePath $updateCADRG_aoiN $updateCADRG_aoiS $updateCADRG_aoiE $updateCADRG_aoiW"

    set imageCount [ossim::getEntryListSize $updateCADRGSourcePath]

    set gotOne 0
    set extents ""

    # foreach image in the data set...
    for {set i 0} {$i < $imageCount} {incr i} {
	#   get nl, ns, corners
	set geom [ossim::getEntryGeometry $updateCADRGSourcePath $i]
	set split [split $geom "\n"]
	set join [join $split]
	set split [split $join ":"]
	set geom [join $split]
	array set geoma $geom
	set ul_lat $geoma(ul_lat)
	set ul_lon $geoma(ul_lon)
	set ur_lat $geoma(ur_lat)
	set ur_lon $geoma(ur_lon)
	set ll_lat $geoma(ll_lat)
	set ll_lon $geoma(ll_lon)
	set lr_lat $geoma(lr_lat)
	set lr_lon $geoma(lr_lon)
	set nl $geoma(number_lines)
	set ns $geoma(number_samples)
	set nb $geoma(number_input_bands)

	set extents "${extents}\nlat [format %.4f $ll_lat] to [format %.4f $ul_lat]\nlon [format %.4f $ll_lon] to [format %.4f $lr_lon]"

	if {$nb != 3} {
	    tk_messageBox -message "Expected 3 bands from input data, but found $nb"
	    return
	}

	if {$ul_lat <= $updateCADRG_aoiS ||
	    $ll_lat >= $updateCADRG_aoiN ||
	    $ll_lon >= $updateCADRG_aoiE ||
	    $lr_lon <= $updateCADRG_aoiW} {
	    continue
	} else {
	    set gotOne 1
	}

	# trim 10x10 to available data
	if {$updateCADRG_aoiN > $ul_lat} {
	    set updateCADRG_aoiN_trimmed $ul_lat
	} else {
	    set updateCADRG_aoiN_trimmed $updateCADRG_aoiN
	}
	if {$updateCADRG_aoiS < $ll_lat} {
	    set updateCADRG_aoiS_trimmed $ll_lat
	} else {
	    set updateCADRG_aoiS_trimmed $updateCADRG_aoiS
	}
	if {$updateCADRG_aoiE > $ur_lon} {
	    set updateCADRG_aoiE_trimmed $ur_lon
	} else {
	    set updateCADRG_aoiE_trimmed $updateCADRG_aoiE
	}
	if {$updateCADRG_aoiW < $ul_lon} {
	    set updateCADRG_aoiW_trimmed $ul_lon
	} else {
	    set updateCADRG_aoiW_trimmed $updateCADRG_aoiW
	}

	#   compute sl, ss, nl, ns of data region touched by 10x10
	set subSl [expr round ((1.0 - ($updateCADRG_aoiN_trimmed - $ll_lat) / ($ul_lat - $ll_lat)) * ($nl - 1))]
	if {$subSl < 0 || $subSl >= $nl} {
	    tk_messageBox -message "subSl == $subSl, but nl == $nl"
	    return
	}
	set subEl [expr round ((1.0 - ($updateCADRG_aoiS_trimmed - $ll_lat) / ($ul_lat - $ll_lat)) * ($nl - 1))]
	if {$subEl < 0 || $subEl >= $nl} {
	    tk_messageBox -message "subEl == $subEl, but nl == $nl"
	    return
	}
	set subNl [expr $subEl - $subSl + 1]

	set subSs [expr round (($updateCADRG_aoiW_trimmed - $ll_lon) / ($lr_lon - $ll_lon) * ($ns - 1))]
	if {$subSs < 0 || $subSs >= $ns} {
	    tk_messageBox -message "subSs == $subSs, but ns == $ns"
	    return
	}
	set subEs [expr round (($updateCADRG_aoiE_trimmed - $ll_lon) / ($lr_lon - $ll_lon) * ($ns - 1))]
	if {$subEs < 0 || $subEs >= $ns} {
	    tk_messageBox -message "subEs == $subEs, but ns == $ns"
	    return
	}
	set subNs [expr $subEs - $subSs + 1]

	# ossim::toVicar expects on-based sl, ss
	incr subSl
	incr subSs

	#   extract region
	puts "ossim::toVicar $updateCADRGSourcePath cadrgUpdate_${i}_r.img $i 0 $subSl $subSs $subNl $subNs"
	global useLastExtraction
	if {! $useLastExtraction} {
	    ossim::toVicar $updateCADRGSourcePath cadrgUpdate_${i}_r.img $i 0 $subSl $subSs $subNl $subNs
	}
	puts "ossim::toVicar $updateCADRGSourcePath cadrgUpdate_${i}_g.img $i 1 $subSl $subSs $subNl $subNs"
	if {! $useLastExtraction} {
	    ossim::toVicar $updateCADRGSourcePath cadrgUpdate_${i}_g.img $i 1 $subSl $subSs $subNl $subNs
	}
	puts "ossim::toVicar $updateCADRGSourcePath cadrgUpdate_${i}_b.img $i 2 $subSl $subSs $subNl $subNs"
	if {! $useLastExtraction} {
	    ossim::toVicar $updateCADRGSourcePath cadrgUpdate_${i}_b.img $i 2 $subSl $subSs $subNl $subNs
	}

	#   present to user for selection of rect to keep
	exec xvd "(cadrgUpdate_${i}_r.img,cadrgUpdate_${i}_g.img,cadrgUpdate_${i}_b.img)" &

	getCadrgCornersAndUpdate cadrgUpdate_${i} $subNl $subNs
    }

    if {! $gotOne} {
	tk_messageBox -message "Requested 10x10 outside all $imageCount data set images. Extents are:${extents}"
    }

}

set dialogId 0
proc getCadrgCornersAndUpdate {pathRoot nl ns} {
    global dialogId
    set thisId [incr dialogId]

    set w .updateCadrg_$thisId
    catch {destroy $w}
    toplevel $w
    wm protocol $w WM_DELETE_WINDOW "destroy $w"
    set title "Update CADRG $pathRoot"
    wm title $w $title
    wm iconname $w $title

    label $w.l -text "Select subarea in line/samp from XVD display for image $pathRoot"
    pack $w.l -side top

    set g $w.frame
    frame $g
    pack $g -side top -fill both -expand true

    set l $g.aoiLabel
    label $l -text "Line/Samp"
    grid $l -row 1 -column 1 -padx 1 -pady 1
    set e $g.aoiN_CadrgLS
    entry $e -width 8 -textvariable updateCadrgLS_${thisId}_aoiN
    global updateCadrgLS_${thisId}_aoiN
    set updateCadrgLS_${thisId}_aoiN 1
    grid $e -row 0 -column 1 -padx 1 -pady 1
    set e $g.aoiS_CadrgLS
    entry $e -width 8 -textvariable updateCadrgLS_${thisId}_aoiS
    global updateCadrgLS_${thisId}_aoiS
    set updateCadrgLS_${thisId}_aoiS $nl
    grid $e -row 2 -column 1 -padx 1 -pady 1
    set e $g.aoiW_CadrgLS
    entry $e -width 9 -textvariable updateCadrgLS_${thisId}_aoiW
    global updateCadrgLS_${thisId}_aoiW
    set updateCadrgLS_${thisId}_aoiW 1
    grid $e -row 1 -column 0 -padx 1 -pady 1
    set e $g.aoiE_CadrgLS
    entry $e -width 9 -textvariable updateCadrgLS_${thisId}_aoiE
    global updateCadrgLS_${thisId}_aoiE
    set updateCadrgLS_${thisId}_aoiE $ns
    grid $e -row 1 -column 2 -padx 1 -pady 1
    
    set row 3

    set bf $g.buttonFrame
    frame $bf
    grid $bf -row $row -column 0
    grid configure $bf -columnspan 3

    set b $bf.update
    button $b -text "Update" -command "updateCadrgSubarea $pathRoot \$updateCadrgLS_${thisId}_aoiN \$updateCadrgLS_${thisId}_aoiE \$updateCadrgLS_${thisId}_aoiW \$updateCadrgLS_${thisId}_aoiS"
    pack $b -side left

    set b $bf.cancel
    button $b -text "Cancel" -command "destroy $w"
    pack $b -side left
}

proc updateCadrgSubarea {pathRoot sl es ss el} {
    global startingUpdateCadrgSourceData
    global adrgRoot
    global CADRG_useAlternateOutdir
    global CADRG_outdir
    
    if {$startingUpdateCadrgSourceData} {
	set indir $adrgRoot
    } else {
	if {$CADRG_useAlternateOutdir} {
	    if {$CADRG_outdir == ""} {
		set indir "."
	    } else {
		set indir $CADRG_outdir
	    }
	} else {
	    set indir $adrgRoot
	}
    }

    set startingUpdateCadrgSourceData 0

    if {$CADRG_useAlternateOutdir} {
	if {$CADRG_outdir == ""} {
	    set outdir "."
	} else {
	    set outdir $CADRG_outdir
	}
    } else {
	set outdir $adrgRoot
    }

    global updateCADRG_aoiS
    global updateCADRG_aoiW

    set slat $updateCADRG_aoiS
    set slon $updateCADRG_aoiW

    set cmd "update_cadrg.pdf inp=$pathRoot slat=$slat slon=$slon sl=$sl ss=$ss el=$el es=$es adir=${indir}/ outdir=${outdir}/"
    global argv
    if {1 || [lsearch $argv "expert"] >= 0} {
	puts $cmd
    }

    if {[catch {exec taetm -s "${cmd}"} erVar]} {
	puts "update_cadrg: $erVar"
	tk_messageBox -title "Update CADRG Completed" -message "The CADRG update completed with error(s); see terminal window for details"
    } else {
	tk_messageBox -title "Update CADRG Completed" -message "The CADRG update completed without errors"
    }
}

proc updateDemSourceData {} {
    global updateDEMSourcePath
    global updateDEM_aoiN
    global updateDEM_aoiS
    global updateDEM_aoiE
    global updateDEM_aoiW
    global srtmRoot
    
    if {[string first "." $updateDEM_aoiN] >= 0 ||
	[string first "." $updateDEM_aoiS] >= 0 ||
	[string first "." $updateDEM_aoiE] >= 0 ||
	[string first "." $updateDEM_aoiW] >= 0} {
	tk_messageBox -message "AOI limits must use integral values" -title "Error: Fractional AOI Limits"
	return
    }

    set split [split $updateDEMSourcePath /]
    set dirIn [join [lrange $split 0 [expr [llength $split] - 3]] /]
    set file [lindex $split [expr [llength $split] - 1]]
    puts "file $file"
    set split [split $file .]
    set insuf [lindex $split [expr [llength $split] - 1]]

    global DEM_useAlternateOutdir
    if {$DEM_useAlternateOutdir} {
	global DEM_outdir
	if {$DEM_outdir == ""} {
	    set dirOut "."
	} else {
	    set dirOut $DEM_outdir
	}
    } else {
	set dirOut $srtmRoot
    }

    set cmd "convert_dted.pdf DIRin=$dirIn DIRout=$dirOut insuf=$insuf slat=$updateDEM_aoiS slon=$updateDEM_aoiW elat=$updateDEM_aoiN elon=$updateDEM_aoiE"
    global argv
    if {[lsearch $argv "expert"] >= 0} {
	puts $cmd
    }

    if {[catch {exec taetm -s "${cmd}"} erVar]} {
	puts "convert_dted: $erVar"
    }

    tk_messageBox -message "DEM import complete" -title "DEM import complete"
}

proc updateVmap1SourceData {} {
    global updateVMAP1SourcePath
    set dhtFilePath $updateVMAP1SourcePath
    # compute lib, coverage, feature, outname

    set split [split $dhtFilePath "/"]
    set chop [lrange $split 0 [expr [llength $split] - 2]]
    set join [join $chop "/"]
    set lib [glob -nocomplain "${join}/lib*"]
    if {$lib == ""} {
	set lib [glob -nocomplain "${join}/LIB*"]
    }

    set split [split $lib "/"]
    set length [llength $split]
    set edition [lindex $split [expr $length -3]]
    set region [lindex $split [expr $length -2]]
    set lib [lindex $split [expr $length -1]]
    set sourceRoot [join [lrange $split 0 [expr $length - 4]] "/"]

    global vmap1Item
    global vmap1Edition

    if {$vmap1Item == "" || $vmap1Edition == ""} {
	tk_messageBox -message "VMAP1 Item and Edition must be specified"
	return
    }

    global vmap1ItemExtent
    if {[lsearch [array names vmap1ItemExtent] $vmap1Item] < 0} {
	tk_messageBox -message "\"$vmap1Item\" is not a known VMAP1 item"
	return
    }

    set outEditionDir ${vmap1Item}_${vmap1Edition}

    set covFeatWidth {
	bnd coastl 35
	bnd polbnda 100
	hydro aquedctl 35
	hydro coasta 35
	hydro lakeresa 35
	hydro swampa 35
	hydro watrcrsa 35
	hydro watrcrsl 35
	phys grounda 35
	pop builtupa 35
	trans bridgel 35
	trans roadl 35
	trans trackl 35
	trans traill 35
	trans tunnell 35
	veg cropa 35
	veg grassa 35
	veg orcharda 35
	veg treesa 35
	veg tundraa 35
	hydro watrcrsl 35
    }

    global vmap1Root
    global VMAP1_useAlternateOutdir
    if {$VMAP1_useAlternateOutdir} {
	global VMAP1_outdir
	if {$VMAP1_outdir == ""} {
	    set dirOut "."
	} else {
	    set dirOut $VMAP1_outdir
	}
    } else {
	set dirOut $vmap1Root
    }

    if {[glob -nocomplain ${dirOut}/${outEditionDir}] == ""} {
	file mkdir ${dirOut}/${outEditionDir}
	puts "Creating ${dirOut}/${outEditionDir}"
    } else {
	puts "Updating ${dirOut}/${outEditionDir}"
    }

    global tdpsRoot
    foreach {cov feat width} $covFeatWidth {
	puts [exec ${tdpsRoot}/vdev/vmap2shp ${sourceRoot}/${edition}/${region}/dht ${lib} ${cov} ${feat} ${dirOut}/${outEditionDir}/${feat} ${width}]
    }

    tk_messageBox -message "VMAP1 import complete" -title "VMAP1 import complete"
}
