procedure
refgbl $echo
parm key string
parm fnamein string
parm nah int def=100
parm nav int def=100
parm rtype string +
   valid=("master","secondary","nightmaster","nightsecondary")
parm dted string
parm lsat string count=(0:1) default=""
parm line_upper int def=0
parm line_lower int def=0
parm samp_left int def=0
parm samp_right int def=0

parm maptype type=string valid=("pc","utm") default="pc"
parm modelfit type=string valid=("noelvcor","elvcor") default="elvcor"
parm angcor type=string valid=("noangcor","angcor") default="noangcor"
parm modiscase int def=0 valid=0:2

parm corband string default="20"

local fname1 string
local fname3 string
local fname4 string
local fname5 string
local fnamecim string
local rawimg string
local rawgeo string

local inroot string
local outroot string
local scratchroot string

local inloc string
local outloc string
local masterloc string
local gridinfoloc string
local gridfinalloc string

local iblat1 real
local iblat2 real
local iblon1 real
local iblon2 real

local qlat real
local qlatinc real
local qlon real
local qloninc real
local slat1 real
local slat2 real
local slon1 real
local slon2 real

local xxxrestore string
local ixclosest int
local lognl int
local logns int
local rlognl real
local rlogns real
local rlogns2 real
local satelv real
local pixdeg real

local stopat int
local ixc1 int
local ixc2 int
local lnl int
local lns int
local ascend int

local ufile string
local ufile2 string
local found int

local xxttemp string
local nscan int

body
let $echo="yes"

let satelv = 704000.0

! may need to be updated for day case to use landsat mosaic alz

if (rtype="nightmaster")
   let stopat=2
else
   let stopat=3
end-if

let inloc = "raw" // "&key" // "/"
let outloc = "final" // "&key" // "/"

let fname1 = "&inloc" // "&fnamein" // "_&corband" // ".img"
let fname3 = "&inloc" // "&fnamein" // ".int"
let fname4 = "&inloc" // "&fnamein" // ".txt"
let fname5 = "scratch/" // "&fnamein" // ".nav"
let xxttemp = "scratch/" // "&fnamein" // ".tutemp"
let fnamecim = "scratch/" // "&fnamein" // ".cimg"
let xxxrestore = "scratch/" // "&fnamein" // ".restore"

!   now the test, real satellite at &satelv

let inroot = "&inloc" // "&fnamein"
let outroot = "&outloc" // "&fnamein"
let scratchroot = "scratch/" // "&fnamein"
let gridinfoloc = "&outloc" // "&fnamein" // "gridinfo"
let gridfinalloc = "&outloc" // "&fnamein" // "gridfinal"
let rawimg = "&inroot" // ".MY02"
let rawgeo = "&inroot" // ".MY03"

!  log the correlation band, depending on day or night


write "logging &rawimg"
if ("&corband"="1" or "&corband"="2")
   modislog_mod02qkm inp=&rawimg geo=&rawgeo out=&inroot +
      band=&corband lineSkip=1 sampSkip=10 maxLat=40
   let nscan = 40
   let pixdeg = 480.0
else-if ("&corband"="lst")
   write "recommend use band 20, then do lst as additional band"
else
   modislog_mod021km inp=&rawimg geo=&rawgeo out=&inroot +
      band=&corband lineSkip=1 sampSkip=10 maxLat=40
   let nscan = 10
   let pixdeg = 120.0
end-if

! for compression testing
compresschk &fname3

ibis-copy &fname3 &fname5

!   prepare the correlation image, and flot if ascending

asc2tcl &fname4 keyword="LOG_ASCENDING=" val=ascend vtype=4
if (ascend=0)
   copy &fname1 &xxttemp
else
   flot &fname1 &xxttemp mode=ROT180
   lab2tcl &xxttemp v1=lnl v2=lns keyword=(nl,ns) 'system
   mf3 &fname5 f="c1=(&lnl)+1-c1$c2=(&lns)+1-c2"
   sort &fname5 sortcol=(1,2)
   ibis-copy &fname5 scratch/xxxxfname5bak
end-if

! do the bowtie correction

bowtie (&xxttemp,&fname5) &fnamecim cols=(1,2,3,4) nscan=&nscan

if (rtype="nightmaster" or rtype="nightsecondary") 
   let masterloc = "&outloc" // "&key" // "nightmaster.img"
else
   let masterloc = "&outloc" // "&key" // "master.img"
end-if

! get the quad from the .txt

write "&fname4"

asc2tcl &fname4 keyword="LOG_MIN_LON=" val=iblon1 vtype=8
asc2tcl &fname4 keyword="LOG_MAX_LON=" val=iblon2 vtype=8
asc2tcl &fname4 keyword="LOG_MIN_LAT=" val=iblat2 vtype=8
asc2tcl &fname4 keyword="LOG_MAX_LAT=" val=iblat1 vtype=8

! walt now providing -999 for whole image, have to get from .nav

if (iblon1<-900.0)
   ibis-copy &fname5 &xxttemp
   mf3 &xxttemp +
       func="c1=c3$c2=c4$@vmin(c1)$@vmin(c2)$@vmax(c3)$@vmax(c4)"
   ibis2tcl &xxttemp v1=iblon1 v2=iblon2 v3=iblat2 v4=iblat1 +
       vartype=(-1,-1,-1,-1) ibisloc=(1,2,1,4,1,1,1,3)
end-if

let qlon = iblon1-0.2
let qloninc = iblon2-iblon1+0.5
let qlat = iblat1+0.4
let qlatinc = iblat1-iblat2+0.8

write "iblon1,iblat1 &iblon1,&iblat1"
write "iblon2,iblat2 &iblon2,&iblat2"
write "qlon,qlat &qlon,&qlat"
write "qloninc,qlatinc &qloninc,&qlatinc"

! get the satellite from the .nav

asc2tcl &fname4 keyword="CALC_NL=" val=lognl vtype=4
asc2tcl &fname4 keyword="CALC_NS=" val=logns vtype=4
let rlognl = $float(lognl)
let rlogns = $float(logns)
let rlogns2 = rlogns*0.5
getpoint fname=&fname5 seq=t resname=&xxxrestore +
   xval=1.0 yval=&rlogns2
restore-variable file=&xxxrestore variable=(ixclosest)
let ixc1 = ixclosest
getpoint fname=&fname5 seq=t resname=&xxxrestore +
   xval=&rlognl yval=&rlogns2
restore-variable file=&xxxrestore variable=(ixclosest)
let ixc2 = ixclosest

ibis2tcl &fname5 v1=slon1 v2=slat1 v3=slon2 v4=slat2 +
    vartype=(-1,-1,-1,-1) +
    ibisloc=(&ixc1,4,&ixc1,3,&ixc2,4,&ixc2,3)

write "ixc1,slon1,slat1 &ixc1,&slon1,&slat1"
write "ixc2,slon2,slat2 &ixc2,&slon2,&slat2"

modwarp inroot=&inroot outroot=&outroot +
   scratchroot=&scratchroot +
   dted="&dted"  lsat="&lsat" +
   seq=qq  pixdeg=&pixdeg angcor=&angcor corband=&corband +
   quad1=&qlat quad2=&qlon quadsiz1=&qlatinc quadsiz2=&qloninc +
   quadunit=0 master=&masterloc +
   gridinfo=&gridinfoloc +
   gridfinal=&gridfinalloc loff=0 soff=0 loff2=0 soff2=0 +
   sensE1=&slon1 sensN1=&slat1 senselv1=&satelv fftsiz=1024 +
   sensE2=&slon2 sensN2=&slat2 senselv2=&satelv sensunit=0 +
   nah=&nah nav=&nav stopat=&stopat rtype=&rtype +
   modelfit=&modelfit maptype=&maptype modiscase=&modiscase +
   line_upper=&line_upper line_lower=&line_lower +
   samp_left=&samp_left samp_right=&samp_right

if (modiscase>0)
   let ufile = "&outroot" // "_map4.&corband"
   file2tcl &ufile val=found
   if (found=0) let ufile = "&scratchroot" // "_map1.&corband"
   let ufile2 = "&ufile" // "x&modiscase"
   copy &ufile &ufile2
   if (rtype="master" or rtype="nightmaster")
      let ufile = "&masterloc"
      let ufile2 = "&masterloc" // "x&modiscase"
      copy &ufile &ufile2
   end-if
end-if

theend>
end-proc
