procedure
refgbl $echo
parm key string
parm rawpre type=(string,99)
parm rawacs type=(string,99)
parm regband type=(string,3) valid=("pn","ms") default="pn"
parm nah int def=100
parm nav int def=100
parm rtype string
parm dted type=(string,99)
parm lsat type=(string,99)
parm line_upper int def=0
parm line_lower int def=0
parm linesamp type=real count=4 +
   default=(-999.0,-999.0,-999.0,-999.0)
parm longlat type=real count=4 default=(0.0,0.0,0.0,0.0)
parm lsatls type=real count=4 +
   default=(-999.0,-999.0,-999.0,-999.0)
parm maptype type=string valid=("pc","utm","ref") default="pc"
parm modelfit type=string valid=("noelvcor","elvcor") default="elvcor"
parm fftinit int def=512
parm xvdonly string valid=("n","y") default="n"
parm outimg type=(string,99)
parm refimg type=(string,99) default=""

parm ecor1 type=real default=0.00
parm ecor2 type=real default=0.00

parm usermapref type=(string,99) default=""
parm interp type=string valid=("bilin","noin") default="bilin"
parm rastype type=string valid=("area","point") default="point"
parm mseph4pn type=(string,2) valid=("y","n") default="n"

parm siteref type=(string,99) default=""
parm siteout type=(string,99) default=""

local fnamein type=(string,99)

local loff real
local wroll real
local roll real

local qlon real
local qloninc real
local qlat real
local qlatinc real
local iblat1 real
local iblat2 real
local iblon1 real
local iblon2 real

local ixclosest int
local ixnext int

local fname3 type=(string,99)
local fname4 type=(string,99)
local fname5 type=(string,99)
local fname6 type=(string,99)

local inroot type=(string,99)
local outroot type=(string,99)
local scratchroot type=(string,99)

local rawkey type=(string,99)

local inloc type=(string,99)
local outloc type=(string,99)

local gridinfoloc type=(string,99)
local gridfinalloc type=(string,99)

local slat1 real
local slon1 real
local slat2 real
local slon2 real

local lognl real
local logns real
local avlat real
local avlat2 real
local coslat real
local pixdeg real

local nl1 real
local ns1 real
local nl2 real
local ns2 real
local nl3 real
local ns3 real

local lon1 real
local lat1 real
local lon2 real
local lat2 real
local lon3 real
local lat3 real

local dlon real
local dlat real

local tstacs real
local tstacs2 real
local zchk1 real
local zchk2 real

local stopat int
local stripnl int
local stripns int

body
let $echo="yes"

write "alicall2 5/15/2008"

! cover walt problem

if (fftinit<128) let fftinit = 128

! now the master is registered to landsat again, both are 6

if (rtype="master")
   let stopat=6
else
   let stopat=6
end-if

if (regband="pn")
   let pixdeg = 10800.0
else
   let pixdeg = 3600.0
end-if

! call walt's routine to generate fnamein

idgen prefix=bob outvar=fnamein

!  log the ali band 3 (or pan), the strips are in rawkey.._3_S1.img, ..S2..S3..S4
!  the align4 will put in rawkey.._b&band.img = fname3
!  the text file is in rawkey w/suffix .txt = fname4

let rawkey = "raw" // "&key" // "/&fnamein"
let inloc = "raw&key/"
let outloc = "final&key/"
let fname4 = "&inloc" // "&fnamein" // ".txt"
let fname5 = "scratch/" // "&fnamein" // ".nav"
let fname6 = "scratch/" // "&fnamein" // ".txt6"
if (regband="ms")
   alilog inpre=&rawpre acs=&rawacs outpre=&rawkey sb=3 nbnd=1
   ush cp &fname4 &fname6
else
   if (mseph4pn="y")
      alilog inpre=&rawpre acs=&rawacs outpre=&rawkey sb=3 nbnd=1
      ush cp &fname4 &fname6
   end-if
   alilog inpre=&rawpre acs=&rawacs outpre=&rawkey sb=1 'pan
   if (mseph4pn="n") ush cp &fname4 &fname6
end-if

asc2tcl &fname4 keyword="ARCH_LINES=" val=stripnl vtype=4
asc2tcl &fname4 keyword="ARCH_SAMPLES=" val=stripns vtype=4
if (regband="ms")
   let fname3 = "&inloc" // "&fnamein" // "_b3" // ".img"
   align4 &rawkey &fnamein stripnl=&stripnl stripns=&stripns band=3
else
   let fname3 = "&inloc" // "&fnamein" // "_b0" // ".img"
   align4p &rawkey &fnamein stripnl=&stripnl stripns=&stripns band=0

end-if

label-add inp=&fname3 items="bobdate=&fnamein" +
         property="COREG_META_DATA"

! for compression testing
compresschk &fname3

if (xvdonly="y")
   xvd &fname3
   goto theend
end-if
   
!   calculating the satellite position from Walt's log file

asc2tcl &fname6 keyword="CALC_STARTLON=" val=slon1 vtype=8
asc2tcl &fname6 keyword="CALC_STARTLAT=" val=slat1 vtype=8
asc2tcl &fname6 keyword="CALC_STOPLON=" val=slon2 vtype=8
asc2tcl &fname6 keyword="CALC_STOPLAT=" val=slat2 vtype=8
if (slon1>180.0) let slon1 = slon1-360.0
if (slon2>180.0) let slon2 = slon2-360.0

write "slon1,slat1 &slon1,&slat1"
write "slon2,slat2 &slon2,&slat2"

let tstacs = linesamp(1)
if (tstacs>(-990.0))
   let slon1 = longlat(1)
   let slat1 = longlat(2)
   let slon2 = longlat(3)
   let slat2 = longlat(4)
   let tstacs2 = lsatls(1)
   if (tstacs2>(-990.0))
      let nl1 = lsatls(1)
      let ns1 = lsatls(2)
      let nl2 = lsatls(3)
      let ns2 = lsatls(4)
      ibis-gen &fname5 nc=4 nr=2 deffmt=DOUB datacol=(1,2) +
         data=(&nl1,&ns1,&nl2,&ns2)
      pixmap (&fname5,&lsat) mapcols=(3,4) pixcols=(1,2) 'pixtomap
      ibis2tcl &fname5 v1=slon1 v2=slat1 v3=slon2 v4=slat2 +
         vartype=(-1,-1,-1,-1) ibisloc=(1,3,1,4,2,3,2,4)
   end-if
end-if

let avlat = (slat1+slat2)*0.5
let avlat = avlat*3.141592/180.0
let avlat2 = avlat*avlat
let coslat = 1.0-avlat2/2.0+avlat2*avlat2/24.0-avlat2*avlat2*avlat2/720.0

!   map the roll that walt calculates to my roll

asc2tcl &fname6 keyword="CALC_STOP_LOOK_ANGLE=" val=wroll vtype=8
let roll = 1.0207922172*wroll-1.3330966624+0.0/&coslat
write "calculated roll = &wroll, program roll = &roll"
let loff = 9.8210201379*wroll-1013.2016450741-0.0/&coslat
write "program loff = &loff, cos(lat) = &coslat"


!calibration 0110405270075_0001_1/EO1A0390322004135110PY case 135
!let roll = 3.567
!let loff = -1017.0

!calibration 0110406010029_0001_1/EO1A0390322004142110KZ case 142
!let roll = 13.998
!let loff = -840.0

!calibration EO1A0390322004144110KY/EO1A0390322004144110KY case 144
!let roll = -6.742
!let loff = -1040.0

if (tstacs>(-990.0))
   let roll = 0.0
   let loff = 0.0
end-if

asc2tcl &fname6 keyword="LOG_NL=" val=lognl vtype=8
asc2tcl &fname6 keyword="LOG_NS=" val=logns vtype=8

!   need to gen a nav file, needs to be close enough for picmatch

let nl1=1
let ns1=logns*0.5
let nl2=lognl
let ns2=logns*0.5
if (tstacs>(-990.0))
   let nl1 = linesamp(1)
   let ns1 = linesamp(2)
   let nl2 = linesamp(3)
   let ns2 = linesamp(4)
end-if
let nl3=ns1-ns2+nl1     ! 90 degree rotation formula, based on square pixels
let ns3=nl2-nl1+ns1

let lat1=slat1
let lon1=slon1
let lat2=slat2
let lon2=slon2
let lat3=(lon2-lon1)*coslat+lat1     ! 90 degree rotation formula, lat minused
let lon3=(lat1-lat2)/coslat+lon1

let dlon = lon3-lon1
let dlat = lat3-lat1

ibis-gen &fname5 version="ibis-2" org=column nc=11 nr=3 deffmt=DOUB +
   data=(&nl1,&ns1,&lat1,&lon1,&dlat,&dlon, +
     &nl2,&ns2,&lat2,&lon2,&dlat,&dlon, +
     &nl3,&ns3,&lat3,&lon3,&dlat,&dlon) +
   datacols=(1,2,5,6,7,8)
ibis-list &fname5 'for
   
! special section for bad ACS file plus failure to input substitute control pts
! via the longlat and linesamp parameters

pixmap (&fname5,&lsat) mapcol=(6,5) pixcol=(9,10) 'maptopix
getzval (&lsat,&fname5) cols=(9,10,11) win=2
ibis2tcl &fname5 v1=zchk1 v2=zchk2 vartype=(-1,-1) ibisloc=(1,11,2,11)
ibis-l &fname5
if ((zchk1<(-998.0)) and (zchk1>(-1000.0))) 
   write "The first control point is not in the Landsat data area"
   write "Possibly a bad ACS file"
   goto theend
end-if
if ((zchk2<(-998.0)) and (zchk2>(-1000.0)))
   write "The second control point is not in the Landsat data area"
   write "Possibly a bad ACS file"
   goto theend
end-if

! adjust for the roll of the platform   
   
mf3 &fname5 f="c9=704000.0*(&roll)/6378206.0"
!mf3 &fname5 f="c11=&coslat"  the next line works better
mf3 &fname5 f="c11=@cos(c5*3.141592/180.0)"
mf3 &fname5 f="c10=@sqrt(c7*c7+c8*c8*(c11*c11))"
mf3 &fname5 f="c3=c5+c9*c7/c10$c4=c6+c9*c8/c10"

if (regband="pn" and mseph4pn="y")
   mf3 &fname5 f="c1=c1*3.0$c2=c2*3.0"
end-if
if (regband="pn")
   let loff = loff*3.0
end-if

ibis-l &fname5
ibis-l &fname5 cols=(1,2,3,4) +
     csiz=(12,12,12,12) cfor="%12.6f%12.6f%12.6f%12.6f"

!   now the test, real satellite at 704000

let inroot = "&inloc" // "&fnamein"
let outroot = "&outloc" // "&fnamein"
let scratchroot = "scratch/" // "&fnamein"
let gridinfoloc = "&outloc" // "&fnamein" // "gridinfo"
let gridfinalloc = "&outloc" // "&fnamein" // "gridfinal"

ibis2tcl &fname5 v1=iblat1 v2=iblat2 v3=iblon1 v4=iblon2 +
      vartype=(-1,-1,-1,-1) ibisloc=(1,3,2,3,1,4,2,4)
let qlon = iblon1-0.35
let qloninc = iblon1-iblon2+0.7
let qlat = iblat1+1.40
let qlatinc = iblat1-iblat2+2.4


write "iblon1,iblat1 &iblon1,&iblat1"
write "iblon2,iblat2 &iblon2,&iblat2"
write "slon1,slat1 &slon1,&slat1"
write "slon2,slat2 &slon2,&slat2"

aliwarp2 inroot=&inroot outroot=&outroot +
   scratchroot=&scratchroot +
   dted=&dted lsat=&lsat +
   seq=rr  pixdeg=&pixdeg fftinit=&fftinit outimg=&outimg +
   quad1=&qlat quad2=&qlon quadsiz1=&qlatinc quadsiz2=&qloninc quadunit=0 +
   master="&refimg" rastype=&rastype +
   gridinfo=&gridinfoloc ecor1=&ecor1 ecor2=&ecor2 +
   gridfinal=&gridfinalloc loff=&loff soff=0 modelfit=&modelfit +
   loff2=0 soff2=0 sensE1=&slon1 sensN1=&slat1 senselv1=704000 +
   sensE2=&slon2 sensN2=&slat2 senselv2=704000 sensunit=0 regband=&regband +
   nah=&nah nav=&nav stopat=&stopat rtype=&rtype interp=&interp +
   line_upper=&line_upper line_lower=&line_lower maptype=&maptype +
   usermapref="&usermapref" +
   siteref="&siteref" +
   siteout="&siteout"

write "MSG: PROCESSING COMPLETED"

theend>
end-proc
