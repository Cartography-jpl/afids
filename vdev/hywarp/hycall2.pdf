procedure
refgbl $echo
parm key string
parm rawl1r type=(string,99)
parm rawacs type=(string,99)
parm rawacorn type=(string,99) default=""
parm acorn type=(string,99) default="no" valid=("no","yes")
parm nah int def=100
parm nav int def=100
parm rtype string
parm dted type=(string,99)
parm lsat type=(string,99)
parm line_upper int def=0
parm line_lower int def=0
parm linesamp type=real count=4 +
   default=(-999.0,-999.0,-999.0,-999.0)
parm longlat type=real count=4 default=(0.0,0.0,0.0,0.0)
parm lsatls type=real count=4 +
   default=(-999.0,-999.0,-999.0,-999.0)
parm maptype type=string valid=("pc","utm","ref") default="pc"
parm modelfit type=string valid=("noelvcor","elvcor") default="elvcor"
parm fftinit int def=512
parm xvdonly string valid=("n","y") default="n"
parm outimg type=(string,99)
parm refimg type=(string,99) default=""

parm ecor1 type=real default=0.00
parm ecor2 type=real default=0.00

parm usermapref type=(string,99) default=""
parm interp type=string valid=("bilin","noin") default="bilin"
parm rastype type=string valid=("area","point") default="point"

parm siteref type=(string,99) default=""
parm siteout type=(string,99) default=""

local fnamein type=(string,99)

local loff real
local wroll real
local roll real

local qlon real
local qloninc real
local qlat real
local qlatinc real
local iblat1 real
local iblat2 real
local iblon1 real
local iblon2 real

local ixclosest int
local ixnext int

local fname3 type=(string,99)
local fname4 type=(string,99)
local fname5 type=(string,99)

local inroot type=(string,99)
local outroot type=(string,99)
local scratchroot type=(string,99)

local rawkey type=(string,99)

local inloc type=(string,99)
local outloc type=(string,99)

local gridinfoloc type=(string,99)
local gridfinalloc type=(string,99)

local slat1 real
local slon1 real
local slat2 real
local slon2 real

local nl int
local ns int
local lognl real
local logns real
local avlat real
local avlat2 real
local coslat real

local nl1 real
local ns1 real
local nl2 real
local ns2 real
local nl3 real
local ns3 real

local lon1 real
local lat1 real
local lon2 real
local lat2 real
local lon3 real
local lat3 real
local lon4 real
local lat4 real

local dlon real
local dlat real

local tstacs real
local tstacs2 real
local zchk1 real
local zchk2 real

local stopat int

body
let $echo="yes"

write "hycall2 5/15/2008"

! cover walt problem

if (fftinit<128) let fftinit = 128

! now the master is registered to landsat again, both are 6

if (rtype="master")
   let stopat=6
else
   let stopat=6
end-if

! call walt's routine to generate fnamein

idgen prefix=bob outvar=fnamein

!  log the hyperion bands 28-34 (averaged) matches landsat band 3

let rawkey = "raw" // "&key" // "/&fnamein"
if (acorn="no")
   hyperionlog inp=&rawl1r acs="&rawacs" out=&rawkey
else
   hyperionlog inp=&rawl1r acs="&rawacs" out=&rawkey acorn=&rawacorn
end-if

let inloc = "raw&key/"
let outloc = "final&key/"

let fname3 = "&inloc" // "&fnamein" // "_28-34" // ".img"
let fname4 = "&inloc" // "&fnamein" // ".txt"
let fname5 = "scratch/" // "&fnamein" // ".nav"

label-add inp=&fname3 items="bobdate=&fnamein" +
         property="COREG_META_DATA"

! for compression testing
compresschk &fname3

if (xvdonly="y")
   xvd &fname3
   goto theend
end-if
   
!   calculating the satellite position from Walt's log file

asc2tcl &fname4 keyword="CALC_STARTLON=" val=slon1 vtype=8
asc2tcl &fname4 keyword="CALC_STARTLAT=" val=slat1 vtype=8
asc2tcl &fname4 keyword="CALC_STOPLON=" val=slon2 vtype=8
asc2tcl &fname4 keyword="CALC_STOPLAT=" val=slat2 vtype=8
if (slon1>180.0) let slon1 = slon1-360.0
if (slon2>180.0) let slon2 = slon2-360.0

if (slon1<-990.0)
   ! this is the edc case
   asc2tcl &fname4 keyword="PRODUCT_UL_CORNER_LAT=" val=lat1 vtype=8
   if (lat1<(-990.0)) goto notedc
   asc2tcl &fname4 keyword="PRODUCT_UL_CORNER_LON=" val=lon1 vtype=8
   asc2tcl &fname4 keyword="PRODUCT_UR_CORNER_LAT=" val=lat2 vtype=8
   asc2tcl &fname4 keyword="PRODUCT_UR_CORNER_LON=" val=lon2 vtype=8
   asc2tcl &fname4 keyword="PRODUCT_LL_CORNER_LAT=" val=lat3 vtype=8
   asc2tcl &fname4 keyword="PRODUCT_LL_CORNER_LON=" val=lon3 vtype=8
   asc2tcl &fname4 keyword="PRODUCT_LR_CORNER_LAT=" val=lat4 vtype=8
   asc2tcl &fname4 keyword="PRODUCT_LR_CORNER_LON=" val=lon4 vtype=8
   
   asc2tcl &fname4 keyword="LOG_NL=" val=nl vtype=4
   asc2tcl &fname4 keyword="LOG_NS=" val=ns vtype=4
   
   let nl1 = 1.0
   let ns1 = 1.0
   let nl2 = 1.0
   let ns2 = $float(ns)
   let nl3 = $float(nl)
   let ns3 = 1.0
   
   ibis-gen &fname5 version="ibis-2" org=column nc=11 nr=3 deffmt=DOUB +
     data=(&nl1,&ns1,&lat1,&lon1,&nl2,&ns2,&lat2,&lon2,&nl3,&ns3,&lat3,&lon3) +
     datacols=(1,2,3,4)
   
   let loff = -230.0
   let slon1 = 0.5*(lon1+lon2)
   let slat1 = 0.5*(lat1+lat2)
   let slon2 = 0.5*(lon3+lon4)
   let slat2 = 0.5*(lat3+lat4)
   
   ibis-l &fname5
   goto edc_case
end-if

notedc>
let tstacs = linesamp(1)
if (tstacs>(-990.0))
   let slon1 = longlat(1)
   let slat1 = longlat(2)
   let slon2 = longlat(3)
   let slat2 = longlat(4)
   let tstacs2 = lsatls(1)
   if (tstacs2>(-990.0))
      let nl1 = lsatls(1)
      let ns1 = lsatls(2)
      let nl2 = lsatls(3)
      let ns2 = lsatls(4)
      ibis-gen &fname5 nc=4 nr=2 deffmt=DOUB datacol=(1,2) +
         data=(&nl1,&ns1,&nl2,&ns2)
      pixmap (&fname5,&lsat) mapcols=(3,4) pixcols=(1,2) 'pixtomap
      ibis2tcl &fname5 v1=slon1 v2=slat1 v3=slon2 v4=slat2 +
         vartype=(-1,-1,-1,-1) ibisloc=(1,3,1,4,2,3,2,4)
   end-if
end-if

let avlat = (slat1+slat2)*0.5
let avlat = avlat*3.141592/180.0
let avlat2 = avlat*avlat
let coslat = 1.0-avlat2/2.0+avlat2*avlat2/24.0-avlat2*avlat2*avlat2/720.0

!   map the roll that walt calculates to my roll

asc2tcl &fname4 keyword="CALC_STOP_LOOK_ANGLE=" val=wroll vtype=8
let roll = 1.019688*wroll-3.641734+1.010088/&coslat
write "calculated roll = &wroll, program roll = &roll"
let loff = 3.435525*wroll-231.461334-8.636198/&coslat
write "program loff = &loff, cos(lat) = &coslat"

!calibration 723 russia 1
!let roll = 7.870
!let loff = -229.0

!calibration 725 russia 2
!let roll = -6.88
!let loff = -270.0

!calibration 926 kabul (kabulrun1)
!let roll = 2.52
!let loff = -239

!calibration 1005 kabul (kabulrun2)
!let roll = -8.74
!let loff = -235.0

!calibration 253 tahoe (tahoerun1)

!let roll = -2.43
!let loff = -129.0

!calibration 244 tahoe (tahoerun2)
!let roll = 7.91
!let loff = -101.0

!calibration 314 tahoe (tahoerun3) 
!let roll = -2.26
!let loff = -270.0

!calibration 129 irwin (irwinrun2) 
!let roll = -14.71
!let loff = -282.0

!calibration 209 irwin (irwinrun5) 
!let roll = -14.75
!let loff = -244.0

!calibration 216 irwin (irwinrun6) 
!let roll = -3.62
!let loff = -280.0

!calibration 120 irwin (irwinrun1) 
!let roll = -5.76
!let loff = -322.0

!calibration 136 irwin (irwinrun3) 
!let roll = -1.995
!let loff = -317.0

!calibration 207 irwin (irwinrun4) 
!let roll = 9.07
!let loff = -243.0

if (tstacs>(-990.0))
   let roll = 0.0
   let loff = 0.0
end-if

asc2tcl &fname4 keyword="LOG_NL=" val=lognl vtype=8
asc2tcl &fname4 keyword="LOG_NS=" val=logns vtype=8

!   need to gen a nav file, needs to be close enough for picmatch

let nl1=1
let ns1=logns*0.5
let nl2=lognl
let ns2=logns*0.5
if (tstacs>(-990.0))
   let nl1 = linesamp(1)
   let ns1 = linesamp(2)
   let nl2 = linesamp(3)
   let ns2 = linesamp(4)
end-if
let nl3=ns1-ns2+nl1     ! 90 degree rotation formula, based on square pixels
let ns3=nl2-nl1+ns1

let lat1=slat1
let lon1=slon1
let lat2=slat2
let lon2=slon2
let lat3=(lon2-lon1)*coslat+lat1     ! 90 degree rotation formula, lat minused
let lon3=(lat1-lat2)/coslat+lon1

let dlon = lon3-lon1
let dlat = lat3-lat1

ibis-gen &fname5 version="ibis-2" org=column nc=11 nr=3 deffmt=DOUB +
   data=(&nl1,&ns1,&lat1,&lon1,&dlat,&dlon, +
     &nl2,&ns2,&lat2,&lon2,&dlat,&dlon, +
     &nl3,&ns3,&lat3,&lon3,&dlat,&dlon) +
   datacols=(1,2,5,6,7,8)
   
! special section for bad ACS file plus failure to input substitute control pts
! via the longlat and linesamp parameters

pixmap (&fname5,&lsat) mapcol=(6,5) pixcol=(9,10) 'maptopix
getzval (&lsat,&fname5) cols=(9,10,11) win=2
ibis2tcl &fname5 v1=zchk1 v2=zchk2 vartype=(-1,-1) ibisloc=(1,11,2,11)
ibis-l &fname5
if ((zchk1<(-998.0)) and (zchk1>(-1000.0))) 
   write "The first control point is not in the Landsat data area"
   write "Possibly a bad ACS file"
   goto theend
end-if
if ((zchk2<(-998.0)) and (zchk2>(-1000.0)))
   write "The second control point is not in the Landsat data area"
   write "Possibly a bad ACS file"
   goto theend
end-if

! adjust for the roll of the platform   
   
mf3 &fname5 f="c9=704000.0*(&roll)/6378206.0"
!mf3 &fname5 f="c11=&coslat"  the next line works better
mf3 &fname5 f="c11=@cos(c5*3.141592/180.0)"
mf3 &fname5 f="c10=@sqrt(c7*c7+c8*c8*(c11*c11))"
mf3 &fname5 f="c3=c5+c9*c7/c10$c4=c6+c9*c8/c10"

ibis-l &fname5
ibis-l &fname5 cols=(1,2,3,4) +
     csiz=(12,12,12,12) cfor="%12.6f%12.6f%12.6f%12.6f"

!   now the test, real satellite at 704000, pixdeg is coarse for test;
!   edc_case is for data that has corner lat-lon in a .MET file

edc_case>

let inroot = "&inloc" // "&fnamein"
let outroot = "&outloc" // "&fnamein"
let scratchroot = "scratch/" // "&fnamein"
let gridinfoloc = "&outloc" // "&fnamein" // "gridinfo"
let gridfinalloc = "&outloc" // "&fnamein" // "gridfinal"

ibis2tcl &fname5 v1=iblat1 v2=iblat2 v3=iblon1 v4=iblon2 +
      vartype=(-1,-1,-1,-1) ibisloc=(1,3,2,3,1,4,2,4)
let qlon = iblon1-0.35
let qloninc = iblon1-iblon2+0.7
let qlat = iblat1+1.40
let qlatinc = iblat1-iblat2+2.4


write "iblon1,iblat1 &iblon1,&iblat1"
write "iblon2,iblat2 &iblon2,&iblat2"
write "slon1,slat1 &slon1,&slat1"
write "slon2,slat2 &slon2,&slat2"
write "qlon,qlat &qlon,&qlat"

hywarp2 inroot=&inroot outroot=&outroot +
   scratchroot=&scratchroot +
   dted=&dted lsat=&lsat +
   seq=rr  pixdeg=3600.0 fftinit=&fftinit outimg=&outimg +
   quad1=&qlat quad2=&qlon quadsiz1=&qlatinc quadsiz2=&qloninc quadunit=0 +
   master="&refimg" rastype=&rastype +
   gridinfo=&gridinfoloc ecor1=&ecor1 ecor2=&ecor2 +
   gridfinal=&gridfinalloc loff=&loff soff=0 modelfit=&modelfit +
   loff2=0 soff2=0 sensE1=&slon1 sensN1=&slat1 senselv1=704000 +
   sensE2=&slon2 sensN2=&slat2 senselv2=704000 sensunit=0 +
   nah=&nah nav=&nav stopat=&stopat rtype=&rtype interp=&interp +
   line_upper=&line_upper line_lower=&line_lower maptype=&maptype +
   usermapref="&usermapref" +
   siteref="&siteref" +
   siteout="&siteout"

write "MSG: PROCESSING COMPLETED"

theend>
end-proc
